<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_server_route.js.html":{"id":"lib_server_route.js.html","title":"Source: lib/server/route.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/route.js 'use strict' /** * represents the middleware stack for a url / method combination * @module skyring/lib/server/route * @author Eric Satterwhite * @since 1.0.0 * @requires path-to-regexp */ const pathToRegExp = require('path-to-regexp') /** * @constructor * @alias module:skyring/lib/server/route * @param {String} path the url pattern to match * @param {String} method The http method to respect * @example var rte = new Route('/foo/:id', 'POST') rte.use((req, res, node, next) =&gt; { if(req.method === 'DELETE') { const err = new Error('Not Implemented') err.statusCode = 501 next(err) } }) **/ function Route(path, method) { this.path = path this.method = method this._keys = [] this.stack = [] this.regexp = pathToRegExp(path, this._keys) this.keys = new Array(this._keys.length) this.params = Object.create(null) for( var idx = 0; idx &lt; this._keys.length; idx++ ) { this.keys[ idx ] = this._keys[ idx ].name this.params[ this._keys[ idx ].name ] = undefined } } /** * Adds a middleware function to the end of the internal route stack * @method module:skyring/lib/server/route#use * @param {module:skyring/lib/server/route~Middleware} fn a the middelware function to add **/ Route.prototype.use = function use(fn) { if (Array.isArray(fn)) { for(var idx = 0; idx &lt; fn.length; idx++) { this.stack.push(fn[idx]) } } else { this.stack.push(fn) } return this } /** * Adds a middleware function to the beginning of the internal route stack * @method module:skyring/lib/server/route#before * @param {module:skyring/lib/server/route~Middleware} fn a the middelware function to add **/ Route.prototype.before = function before(fn) { if (Array.isArray(fn)) { this.stack.unshift(...fn) } else { this.stack.unshift(fn) } return this } Route.prototype.match = function match(path) { const matches = this.regexp.exec(path) if (!matches) return null const keys = this.keys const params = Object.assign({}, this.params) for (var idx = 1; idx &lt; matches.length; idx++) { params[keys[idx - 1]] = matches[idx] } return params } Route.prototype.process = function process(req, res, node, next) { const stack = this.stack ;(function run( idx ) { const fn = stack[idx] try { fn(req, res, node, (err, body) =&gt; { if ( err ) return next( err ) if( idx === stack.length -1 ) return next() run(++idx) }) } catch ( err ){ err.statusCode = err.statusCode || 500 return next( err ) } })(0) } module.exports = Route /** * A route middleware function * @typedef {Function} Middleware * @param {http.IncomingMessage} req The incomming request * @param {http.ServerResponse} res The response object to be sent * @param {module:skyring/lib/server/node} node The internal Ring Node instance * @param {Function} next The continuation callback to call when the middleware is finished **/ × Search results Close "},"node_modules_keef_index.js.html":{"id":"node_modules_keef_index.js.html","title":"Source: node_modules/keef/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: node_modules/keef/index.js /*jshint node:true, laxcomma: true, smarttabs: true*/ 'use strict' /** The conf package reads configurations options in an overriding fashion from a number of sources. In order of importance: 1. System level overrides 2. Command line arguments 3. Environment variables 4. A configuration file(s) 5. System specified defaults ### Overrides Overrides can not be overriden or changed at any point in time. The are defined in `conf/lib/overrides.js` and should be reserved for static run time properties. Conf serves as a central place to get that information. For example, the full path to the packages directory is resolved at run time and loaded in to the conf loader. It won't / can't change during run time, but may change in the future. By getting the information from conf, application logic does not need to change between restarts or releases. If overrides need to be change or added the `overrides.js` file must be changed ### Command Line Arguments Command line arguments are the highest level of maliable values. The can be used to set specific and nested values in the configuration JSON document but using a `:` spearator between keys. For example, using the flag: `--foo:bar=1`, would create an object like ```js { \"foo\":{ \"bar\": 1 } } ``` ### Environment Variables Environment variables work much the same as command line arguments. However, most bash implenetations don't read `:`'s very well, so the double underscore ( `__` ) is used in its place `foo__bar=1` npm start ```js { \"foo\":{ \"bar\": 1 } } ``` ### Conf Options The `conf` option can be set to read specific configuration from a file(s). The value should be a full path. If the path points to a directory, the conf loader will read all json files, sort them and load their values in an overriding order. Sorting is done in a descending, lexigraphical order. ```sh └── conf ├── 20-keef.json ├── 10-keef.json └── 30-keef.json ``` Given the above directory of conf files, the server can be configured by pointing the `conf` arguments at the directory ```sh node server --conf=$HOME/conf ``` The configruation would be read in the following priority ``` 10-keef.json &lt; 20-keef.json &lt; 30-keef.json``` where 20 overrides 10, and 30 overrides 20. ### Static File Defaults To Simplify configuration for deployments, `keef` will look for configuration files in fixed locations eliminating the need for run time configuration. File Locations are as follows: 1. a file in the rooot of your project with the name `&lt;package.name&gt;`.`NODE_ENV`.`json` For example, if the `name` attribute in your package.json is `foobar`, and the environment var `NODE_ENV` is set as `production`, the file look up is `foobar.production.json`. If `NODE_ENV` is not set, it would be `foobar.development.json` 2. A json file named after your project name in the root of your project - `foobar.json` 3. A json file named after your project in a `.config` directory in the current users home directory - `.config/foobar.json` 4. A json file named after your project in the `/etc` directory - `/etc/foobar.json ### ETCD2 Clusters For distributed deployments, An etcd2 cluster may be used for configuration purposes. To enable `etcd2` configuration loading, 2 environment variables should be set: 1. `etcd__hosts` - A comma separated list of `host`:`port` addresses - `etcd1.domain.com:4001,etcd2.domain.com:4001`. 2. `etcd__namespace` - a keyspace to keep data separate from everything else. Any configuration that is stored as object, we be translated into `etcd` directories automatically ```js keef.set('a:b:c', 1) // Object data { \"a\": { \"b\": { \"c\": 1 } } } // etc data /a/b/c 1 ``` ### System defaults defaults are what they sound like. Sane defaults for values that are needed to get the application running. They are located in the {@link module:keef/lib/defaults|Defaults} module and are used only as fallback values. ### Option Shorthands Top level options can be aliased. Short hand aliases can be found and defined in the {@link module:keef/lib/shorthands|Shorthands} module of `keef` Flag | Shorthand | Description -----|:---------:|:------------ PORT | p | Specifies the port the server will bind to logger | l | specify the type(s) of logging transports for the server to use the following invocations are treated the same ```sh node server --PORT=3001 --logger=stdout --logger=file ``` ```sh PORT=3001 logger=stdout nodeserver -l file ``` ```sh node server -p 3001 -l stdout -l file ``` * @summary The configuration loader for keef, the spirit shop platform api.* * @module keef * @author Eric Satterwhite * @since 0.1.0 * @requires nconf * @requires path * @requires os * @requires debug * @requires fs * @requires keef/lib/shorthands * @requires keef/lib/defaults * @requires keef/lib/overrides */ var nconf = require( 'nconf' ) // flatiron nconf module , path = require( 'path' ) // node path module , util = require( 'util' ) // node path module , os = require( 'os' ) // node os module , fs = require( 'fs' ) // node fs module , debug = require( 'debug' )('keef:conf') // debug function spoped to keef:conf , shorthands = require('./lib/shorthands') // quick argv shorthands mapping , defaults = require('./lib/defaults') // config defaults , overrides = require('./lib/overrides') // static system overrides that can't / shouldn't change , merge = require('extend') , keefcheck = /^keef/ , csv_exp = /(?:\\s+)?,(?:\\s+)?/ , apppaths = [ ] , defaultCfg = {} , cwd = process.cwd() , modules , lookuppaths // look up paths to possible locations where config files may live , startup // referece to the conf object for start up options. Gets deleted at the end , configFile // the location to look for a user defined config file, or a directory , envFile , pkg , pkgname , pkgfile , etc_config , conf ; startup = nconf .argv() .env({separator:'__'}) .defaults( defaults ) try { pkg = path.join(overrides.PROJECT_ROOT, 'package.json') pkgname = require(pkg).name.trim() } catch( e ){ debug('package error ', e.message) pkgname = 'default' } pkgfile = pkgname +'.json' envFile = util.format('%s.%s.json', pkgname, startup.get('NODE_ENV') || 'development') envFile = path.resolve( cwd, envFile) debug(\"package info: \", pkgname, pkg) // order matters, otherwise this could be an object lookuppaths =[ ['nenv', envFile ] , ['project', path.normalize( path.join( overrides.PROJECT_ROOT, pkgfile ) )] , ['home',path.normalize( path.join(( process.env.USERPROFILE || process.env.HOME || overrides.PROJECT_ROOT ),'.config', pkgfile) ) ] , ['etc', path.normalize('/etc/' + pkgfile )] ] configFile = path.resolve( startup.get( 'conf' ) || pkgfile ) overrides.CONFIG_PATH = configFile startup.remove('env') startup.remove('argv') startup.remove('defaults') startup = null debug('config file set to %s', configFile ) debug('project root set to %s', overrides.PROJECT_ROOT ) debug('package path set to %s', overrides.PACKAGE_PATH ) conf = nconf .overrides( overrides ) .argv( shorthands ) .env({separator:'__', parseValues: true, lowerCase: true}) // if the specified config file is actually a directory // start looking for json files and try to sort them if( fs.existsSync( configFile ) ) { if( fs.statSync( configFile ).isDirectory() ) { debug('detected config directorty') fs .readdirSync( configFile ) .filter(( file ) =&gt; { return (/\\.json$/).test( file ) }) .sort(( file_a, file_b ) =&gt; { return file_a &lt; file_b }) .forEach(( file ) =&gt; { var filepath = path.normalize( path.join( configFile, file ) ) debug('loading config file `%s` %s', file, filepath) conf = conf.file( file, filepath ) }) } else { conf = conf.file( 'conf', configFile ) } } for (const lp of lookuppaths) { debug('loading config file `%s`: %s', lp[0], lp[1]) conf = conf.file( lp[0], lp[1] ) } apppaths = conf.get(pkgname + ':applications') || [] apppaths = Array.isArray( apppaths ) ? apppaths : [apppaths] apppaths.push( cwd ) debug('setting config defaults') debug(\"configuration modules %s\", apppaths.join(', ')) for (const pconf of apppaths) { try { const config = require( path.join( pconf, 'conf' ) ) defaultCfg = merge(true, {}, defaultCfg, config ) debug('loaded package defaults from %s', pconf ) } catch( e ) { debug('unable to load %s configuration: %s', pconf, e.message ) } } etc_config = conf.get('etcd') debug('etcd config: ', etc_config ) if( etc_config &amp;&amp; etc_config.hosts ){ try { require('nconf-etcd2') var etc_hosts = toArray( etc_config.hosts ); debug('found etcd hosts:', etc_hosts) etc_config.hosts = etc_hosts; etc_hosts &amp;&amp; conf.use('etcd', etc_config ) } catch (e) { debug('unable to load etcd configuration', e) } } apppaths.pop() defaultCfg = merge(true, {}, defaultCfg, defaults ) conf.defaults(defaultCfg) function toArray(item) { if (!item) return [] if (Array.isArray(item)) return item return typeof item === 'string' ? item.split(csv_exp) : [item] } module.exports = conf; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: index.js 'use strict'; /** * Distributed timers as a service * Exports a default server instance. If executed directly, the server will be started automoaticall and configured to auto rebalance on `SIGINT` and `SIGTERM` * @module skyring * @author Eric Satterwhite * @since 1.0.0 * @requires http * @requires debug * @requires keef * @requires skyring/lib/server **/ const conf = require('./conf') , Server = require('./lib/server') , Transports = require('./lib/transports') , Transport = require('./lib/transports/transport') , debug = require('debug')('skyring:main') ; module.exports = Server; module.exports.Transport = Transport; module.exports.Transports = Transports if(require.main === module){ process.title = 'skyring'; process.chdir(__dirname); const server = new Server(); server.listen(conf.get('port'), (err) =&gt; { /* istanbul ignore if */ if(err) { process.exitCode = 1; console.error(err); throw err; } debug('server listening', conf.get('port')); }); function onSignal() { server.close(()=&gt;{ debug('shutting down'); }); } process.once('SIGINT', onSignal); process.once('SIGTERM', onSignal); } /** * Configuration options for skyring. See {@link module:keef} on ways to pass configuration * @module skyring/conf * @author Eric Satterwhite * @since 1.0.0 * @property {String|String[]} [seeds=127.0.0.1:3455,127.0.0.1:3456] A list of seed nodes to use for bootstrapping a ring cluster * @property {Object} channel * @property {String} [channel.host=127.0.0.1] hostname or ip addres for tchannel to listen on * @property {Number} [channel.port=3455] Port number for tchannel to bind to * @property {Number} [PORT=3000] The port number for the http API server to bind to * @property {Object} nats Nats queue specific configuration * @property {String|String[]} [nats.hosts=127.0.0.1:4222] host:port of instances of a nats cluster. One is usually enough. * @property {Object} [options.storage] Storage config options for level db * @property {String[]} [options.storage.backend=memdown] a requireable module name, or absolute path to a leveldb compatible backend * `leveldown` and `memdown` are installed by default * @property {String} options.storage.path A directory path to a leveldb instance. One will be created if it doesn't already exist. * @param {String[]|Function[]} [optsion.transport] an array of custom transport functions, or requireable paths that resolve to functions. All transport function must be named functions * If the backend is memdown, this is optional and randomly generated per timer instance **/ × Search results Close "},"lib_json.js.html":{"id":"lib_json.js.html","title":"Source: lib/json.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/json.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * JSON helpers * @module skyring/lib/json * @author Eric Satterwhite * @since 1.0.0 */ /** * Composite JSON ojbect * @typedef {Object} Result * @property {?Error} [error=null] An error if json parsing faile * @property {Object} value the result of Json parsing **/ /** * Wrpper around try/catch of JSON parsing * @method module:skyring/lib/json * @param {String} json A JSON string to parse * @return {module:skyring/lib/json~Result} **/ exports.parse = function parse(json) { if (!json) return {error: null, value: {}}; try { return { error: null, value: JSON.parse(json) }; } catch( e ) { return { error: e, value: null }; } }; × Search results Close "},"lib_nats_index.js.html":{"id":"lib_nats_index.js.html","title":"Source: lib/nats/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/nats/index.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * Small wrapper around nats for quickly connecting / disconnecting * @module skyring/lib/nats * @author Eric Satterwhite * @since 1.0.0 * @requires url * @requires nats * @requires keef * @requires debug * @example const nats= require('skyring/lib/nats') const client = nats.createClient() client.publish('foobar', JSON.stringify({'foo':'bar'}), () =&gt; { nats.quit() }) */ const nats = require('nats') , parseHosts = require('./parse-hosts') , config = require('../../conf') , debug = require('debug')('skyring:nats') , nats_hosts = config.get('nats:hosts') /** * Creates a new nats client * @method module:skyring/lib/nats#createClient * @param {Object} [options] nats client configuration * @param {String} [options.hosts=localhost:4222] a comma separated list of addresses of nats hosts to connect to * @return {NatsClient} A nats client instance * @example nats.createClient({ hosts:'nats-1.domain.com:4222,nats-2.domain.com:4223,localhost:4222' }) **/ exports.createClient = createClient; function createClient(options) { const hosts = (options &amp;&amp; options.hosts) || nats_hosts; const servers = parseHosts(hosts); const opts = Object.assign({json: true}, options, {servers}); debug('creating nats client', opts); const client = nats.connect(opts); /* istanbul ignore next*/ client.on('error', (err) =&gt; { console.error('nats error', err); }); client.on('connect', () =&gt; { debug('nats connection successful'); }); /* istanbul ignore next*/ client.on('close', () =&gt; { debug('nats connection closed'); client.removeAllListeners(); }); /* istanbul ignore next*/ client.on('disconnect', () =&gt; { debug('nats connection disconnected'); }); /* istanbul ignore next*/ client.on('reconnecting', () =&gt; { debug('nats client reconnecting'); }); client.quit = (cb) =&gt; { debug('closing nats', client.info.server_id); client.close(); client.once('disconnect', cb); }; return client; } × Search results Close "},"lib_nats_parse-hosts.js.html":{"id":"lib_nats_parse-hosts.js.html","title":"Source: lib/nats/parse-hosts.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/nats/parse-hosts.js 'use strict' /** * Function to parse and normalize nats host addresses * @module skyring/lib/nats/parse-hosts * @author Eric Satterwhite * @since 10.0.0 **/ const csv_exp = /\\s?,\\s?/g module.exports = parseHosts function parseHosts(str) { if (Array.isArray(str)) return str.map(parseItem) if (typeof str !== 'string') { throw new TypeError('nats hosts must be a string'); } const items = str.split(csv_exp); return items.map(parseItem); } function parseItem(str) { return str.indexOf('nats://') === 0 ? str : `nats://${str}`; } × Search results Close "},"lib_server_index.js.html":{"id":"lib_server_index.js.html","title":"Source: lib/server/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/index.js /*jshint laxcomma: true, smarttabs: true, node: true, esnext: true*/ 'use strict' /** * Primary server instance for a skyring app. * @module skyring/lib/server * @requires http * @requires debug * @requires @esaterwhite/micromock * @requires skyring/lib/server/node * @requires skyring/lib/server/router * @requires skyring/lib/timer */ const {isFunction} = require('util') const http = require('http') const mock = require('@esatterwhite/micromock') const util = require('util') const Debug = require('debug') const routes = require('./api') const Node = require('./node') const Router = require('./router') const Timer = require('../timer') const conf = require('../../conf') const debug = Debug('skyring:server') /** * @constructor * @extends http.Server * @alias module:skyring/lib/server * @author Eric Satterwhite * @since 1.0.0 * @param {Object} [options] * @param {module:skyring/lib/server/node} [options.node] A customer node instance * @param {String} [optiopns.node.host] host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0 ) * @param {Number} [options.node.port] Port number for the node to listen on in the ring * @param {String} [options.node.app=timers] name of the active ring to join * @param {Object} [options.nats] * @param {String[]} [options.nats.servers] An array of nats `host:port` addresses to connect to * @param {String[]|Function[]} [options.transports] an array of custom transport functions, or requireable paths that resolve to functions. All transport function must be named functions * @example // Use only configuration values var server = new Server().listen(5000) * @example var server = new Server({ node :{ host: 172.17.0.9 , port: 8456 , app: 'payback' } , nats: { servers: ['nats1.domain.com:4222', 'nats2.domain.com:4222'] } }) server.listen(5000) * @example // Use a custom node instance var node = new Node({ host: 172.17.0.9 , port: 8456 , app: 'payback' }) var server = new Server({ node }) server.listen(5000) */ class Server extends http.Server { constructor(opts = {}){ super((req, res) =&gt; { this._router.handle(req, res) }) this.closed = false this.options = Object.assign({}, { seeds: null , nats: null , storage: null , transports: [] , autobalance: conf.get('autobalance') }, opts) /* istanbul ignore else */ if(opts.node) { this._node = opts.node instanceof Node ? opts.node : new Node( opts.node.host, opts.node.port, opts.node.name, opts.node.app ) } else { this._node = new Node() } this._group = this._node.name this._node.on('bootstrap', (seeds) =&gt; { this.emit('bootstrap', seeds) }) } route(opts) { const route = this._router.route(opts.path, opts.method, opts.handler) opts.middleware &amp;&amp; route.before( opts.middleware ) debug('loaded: %s %s', opts.method, opts.path) } /** * Joins the node to the configured ring and starts the http server * @method module:skyring/lib/server#listen * @param {Number} port Port number to listen on * @param {String} [host=localhost] host or ip address to listen on * @param {Number} [backlog] * @param {Function} [callback] Callback function to call when the server is running * @return {module:skyring/lib/server} **/ listen(port, ...args) { const callback = args[args.length - 1] if (this.listening) return isFunction(callback) ? callback() : null debug('seed nodes', this.options.seeds) this._timers = new Timer({ nats: this.options.nats , storage: this.options.storage , transports: this.options.transports }, (err) =&gt; { if (err) return isFunction(callback) ? callback(err) : null this._router = new Router(this._node, this._timers) for (const key of Object.keys(routes)) { const item = routes[key] const route = this._router.route( item.path , item.method , item.handler ) debug('loaded: %s %s', item.method, item.path) item.middleware &amp;&amp; route.before( item.middleware ) } // When nodes are added / removed exec a rebalanace of local timers // If this node is not the owner, sent it back in the ring if (this.options.autobalance) { this._node.on('ringchange', this._rebalance.bind(this)) } process.on('SIGUSR2', this._rebalance.bind(this)) // Join the ring this._node.join(this.options.seeds, (err) =&gt; { /* istanbul ignore if */ if (err) { return isFunction(callback) ? callback(err) : null } // delegate mock requests from the ring to the // API router this._node.handle(( req, res ) =&gt; { this._router.handle( req, res ) }) // listen for timers being purged over nats when a remote // node is evicted or shutdown this._timers.watch(`skyring:${this._group}`, (err, data) =&gt; { this.proxy(data) }) debug('binding to port', port) super.listen(port, ...args) }) }) return this } _rebalance(evt = {}) { this._timers.rebalance(evt, this._node, (data) =&gt; { this.proxy(data) }) } proxy(data) { debug('fabricating request', data.id) const opts = { url: '/timer' , method: 'POST' , headers: { \"x-timer-id\": data.id } , payload: JSON.stringify(data) } const res = new mock.Response() const req = new mock.Request(opts) debug('routing fabricated request', data.id) this._router.handle(req, res) this.emit('proxy', data) } /** * Removes a server from the ring, closes the http server and redistributes * any pending timers * @method module:skyring/lib/server#close * @param {Function} callback A callback to be called when the server is completely shut down **/ close( cb ){ if(this.closed) return isFunction(cb) ? setImmediate(cb) : null super.close(() =&gt; { this._node.close(() =&gt; { const active = this._node._ring.membership.members.filter((m) =&gt; { return m.status === 'alive' }) if (active.length) { return this._timers.shutdown(() =&gt; { debug('closing server') this.closed = true cb &amp;&amp; cb() }) } debug('Last node in cluster - skipping rebalanace') this._timers.disconnect(() =&gt; { debug('closing server') this.closed = true cb &amp;&amp; cb() }) }) }) } } module.exports = Server module.exports.Router = Router × Search results Close "},"lib_server_node.js.html":{"id":"lib_server_node.js.html","title":"Source: lib/server/node.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/node.js 'use strict' /** * Represents a participant in the Hashring * @module skyring/lib/server/node * @author Eric Satterwhite * @since 1.0.0 * @requires path * @requires events * @requires dns * @requires @skyringringpop * @requires tchannel * @requires debug * @requires keef */ const path = require('path') const EventEmitter = require('events').EventEmitter const dns = require('dns') const Ringpop = require('@skyring/ringpop') const TChannel = require('tchannel') const debug = require('debug')('skyring:ring') const conf = require(path.join(__dirname, '..', '..', 'conf')) const host = conf.get('channel:host') const port = ~~conf.get('channel:port') let ring_seeds = conf.get('seeds') ring_seeds = !Array.isArray(ring_seeds) ? ring_seeds.split(',') : ring_seeds function resolve(tasks, cb) { const results = [] ;(function next() { if (!tasks.length) return cb(null, results) const task = tasks.shift() const [h, p] = task.split(':') dns.lookup(h, (err, addr) =&gt; { if (err) return cb(err) results.push(`${addr}${p ? ':' + p : ''}`) next() }) })() } /** * @constructor * @alias module:skyring/lib/server/node * @param {String} [host] host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0) * @param {Number} [port] Port number for the node to listen on in the ring * @param {String} [name='ringpop'] name of the active ring to join * @param {String} [app=timers] app name of the active ring */ class Node extends EventEmitter { constructor(h = host, p = port, name = 'ringpop', app = 'timers') { super() this._port = p this._host = host this._name = name this._app = app this._tchannel = new TChannel() this._ring = null } /** * Does the work of configuring tchannel and joining itself into a ringpop ring * @method module:skyring/lib/server/node#join * @param {String[]} [seeds] An array of node addresses to use as boot strapping nodes * @param {Function} callback Function to call when the node has completed the bootstrap process * @example node.join(['node-1:5555', '172.10.0.4:4563'], (err) =&gt; { if (err) throw err }) **/ join(seed_arr, cb) { const nodes = seed_arr || ring_seeds if (!Array.isArray(nodes)) { const err = new TypeError('seeds must be an array') return cb(err) } const addrs = [this._host].concat(nodes) resolve(addrs, (err, seeds) =&gt; { debug('seed nodes', seeds) if (err) return cb(err) const host = seeds.shift() this._ring = new Ringpop({ app: this._app , hostPort: `${host}:${this._port}` , channel: this._tchannel.makeSubChannel({ serviceName: this._name , trace: false }) }) this._ring.setupChannel() this._ring.on('ringChanged', (evt) =&gt; { const added = evt.added if (!added.length) return debug('node removed', evt.removed) if (added.length === 1 &amp;&amp; added.indexOf(`${host}:${this._port}`) !== -1) return debug('node added', added) this.emit('ringchange', evt) }) this._tchannel.listen(this._port, host, (er) =&gt; { if (er) return cb(er) debug('tchannel listening on ', host, this._port) this._ring.bootstrap(seeds, (er) =&gt; { if (er) return cb(er) debug('ring bootstraped', seeds) this.emit('bootstrap', seeds) cb(null) }) }) }) } /** * Adds a request handler to the active ringpop instance * @method module:skyring/lib/server/node#handle * @param {Function} handler A request handler for incoming requests from the ring **/ handle(cb) { return this._ring.on('request', cb) } /** * Determines if this instance is responsible for a specific key. * proxies the request if it is not * @method module:skyring/lib/server/node#handleOrProxy * @param {String} key The key to use to do a node lookup in the ring * @param {http.IncomingMessage|module:skyring/lib/server/mock.Request} req an http request object * @param {http.ServerResponse|module:skyring/lib/server/mock.Response} res an http response object * @example const handle = node.handleOrProxy('foobar', req, res) if (!handle) return; // deal with request * @return {Boolean} **/ handleOrProxy(key, req, res) { return this._ring.handleOrProxy(key, req, res) } /** * Determines if this node is responsible for a specific key * @method module:skyring/lib/server/node#owns * @param {String} key The key to use * @return {Boolean} **/ owns(key) { return this.lookup(key) == this._ring.whoami() } /** * Lookup the address of the server responsible for a given key * @method module:skyring/lib/server/node#lookup * @param {String} key The key to look up * @return {String} A server address **/ lookup(key) { return this._ring.lookup(key) } /** * Deprecated: use close method * @deprecated 10.0.0 * @method module:skyring/lib/server/node#leave * @param {Function} callback Callback function to call when the eviction process is complete **/ leave(cb) { this.close(cb) } /** * Removes itself from the ring and closes and connections * @method module:skyring/lib/server/node#close * @param {Function} callback A callback function to call when the ring is closed **/ close(cb) { debug('node close') this._ring.selfEvict(() =&gt; { debug('draining tchannel') this._tchannel.drain('leaving', () =&gt; { debug('destroying ring') this._ring.once('destroyed', () =&gt; { setTimeout(cb, 100) }) this._ring.destroy() }) }) } } Object.defineProperty(Node.prototype, 'name', { get: function() { /** * @readonly * @name name * @memberof module:skyring/lib/server/node * @property {String} name The name of the node **/ return this._app } }) module.exports = Node × Search results Close "},"lib_server_request.js.html":{"id":"lib_server_request.js.html","title":"Source: lib/server/request.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/request.js /*jshint laxcomma: true, smarttabs: true, node:true, esnext:true*/ 'use strict'; /** * Simple wrapper around the http request object to avoid deopts * @module skyring/lib/server/request * @author Eric Satterwhite * @since 1.0.0 * @requires url * @requires querystring */ const {Url} = require('url') , qs = require('querystring') , cache = new WeakMap() , pathexp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/ ; /** * @constructor * @alias skyring/lib/server/request * @param {IncommingMessage} req An {@link https://nodejs.org/api/http.html#http_class_http_incomingmessage|IncomingMessage} * from the node http module */ function Request(req) { this.query = Object.create(null); this.path = null; this._body = false; this.body = null; this.timers = null; this.res = null; this.headers = req.headers; const parsed = parseurl(req); if (parsed) { this.query = parsed.query; this.path = parsed.pathname; } } /** * Returns the value of a header, if it exists * @param {String} header The name of the header to lookup * @returns {String} The request header, if set */ Request.prototype.get = function get( key ) { const _key = key.toLowerCase(); const headers = this.headers || {}; switch (_key) { case 'referrer': case 'referer': return headers.referrer || headers.referer; default: return headers[_key]; } }; function parseurl( req ) { const url = req.url; if (!url) return url; if ( cache.has(req) ) return cache.get(req); const parsed = fastparse(url); cache.set(req, parsed); return parsed; } function fastparse( str ) { const simple = typeof str === 'string' &amp;&amp; pathexp.exec( str ); if ( simple ) { const pathname = simple[1]; const search = simple[2] || null; const url = new Url(); url.path = str; url.href = str; url.pathname = pathname; url.search = search; url.query = url.search ? qs.parse( search.substr( 1 ) ) : Object.create(null); return url; } return parseurl( str, true ); } module.exports = Request; × Search results Close "},"lib_server_response.js.html":{"id":"lib_server_response.js.html","title":"Source: lib/server/response.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/response.js 'use strict'; /** * Simple wrapper around the http response object to avoid deopts * @module skyring/lib/server/response * @author Eric Satterwhite * @since 1.0.0 * @requires debug */ const debug = require('debug')('skyring:error'); /** * @constructor * @alias module:skyring/lib/server/response * @param {ServerResponse} res A {@link https://nodejs.org/api/http.html#http_class_http_serverresponse|ServerResponse} * from the node http module */ function Response( res ) { this.res = res; this.body = null; } /** * Responsible for returning a response in the case of an error * If the error has a message, it will be sent with the `x-skyring-reason` http header * if the error has a `statusCode` property, that will be used, otherwise a 500 will be returned * @method module:skyring/lib/server/response#error * @param {Error|number} err The error to handle * @param {String} [msg] In the case `err` is a number, this will be used as the message */ Response.prototype.error = function error( err, msg ) { if(typeof err === 'number') { this.res.setHeader('x-skyring-reason', msg || 'Internal Server Error'); return this.status(err).json({ message: msg }); } err.statusCode = err.statusCode || err.code; if(!err.statusCode) { err.statusCode = 500; err.message = 'Internal Server Error'; } this.status(err.statusCode); debug(err); this.res.setHeader('x-skyring-reason', err.message); return this.end(); }; /** * Returns the value of a response header * @method module:skyring/lib/server/response#get * @param {String} header The name of the header to get * @returns {String} The header value, if it is set */ Response.prototype.get = function get( key ) { return this.res.getHeader(key); }; /** * Helper for responding with an Object. Will serialize the object, and set the * Content-Type header to `application/json` * @chainable * @method module:skyring/lib/server/response#json * @param {Object} body The object to set as the response body * @returns {module:skyring/lib/server/response} */ Response.prototype.json = function json( body ) { this.res.setHeader('Content-Type', 'application/json'); this.res.end(JSON.stringify(body)); return this; }; /** * Sets a response header * @chainable * @method module:skyring/lib/server/response#set * @param {String} header The header to set * @param {String} The header value to set * @returns {module:skyring/lib/server/response} */ Response.prototype.set = function set( key, val ) { const value = Array.isArray(val) ? val.map(String) : typeof val === 'string' ? val : String(val); this.res.setHeader(key, value); return this; }; /** * Sets the status code on the response object * @chainable * @method module:skyring/lib/server/response#status * @param {Number} code The http Status code to set * @returns {module:skyring/lib/server/response} */ Response.prototype.status = function status( code ) { this.res.statusCode = code; return this; }; /** * Writes a chunk to the response stream * @chainable * @method module:skyring/lib/server/response#send * @param {String} [chunk] The chunk to write * @returns {module:skyring/lib/server/response} */ Response.prototype.send = function send( str ) { this.res.write(str); return this; }; /** * Ends the response * @method module:skyring/lib/server/response#end * @param {String} [chunk] An optional chunk to write be for closing the stream * @returns {module:skyring/lib/server/response} */ Response.prototype.end = function end( str ) { this.res.end(str); return this; }; module.exports = Response; × Search results Close "},"lib_server_router.js.html":{"id":"lib_server_router.js.html","title":"Source: lib/server/router.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/server/router.js /*jshint laxcomma: true, smarttabs: true, node: true, esnext: true*/ 'use strict' /** * Simple router class for directing requests * @module skyring/lib/server/router * @author Eric Satterwhite * @since 1.0.0 * @requires skyring/lib/server/route * @requires skyring/lib/server/request * @requires skyring/lib/server/response */ const Route = require('./route') const Request = require('./request') const Response = require('./response') const debug = require('debug')('skyring:server:router') /** * @constructor * @alias module:skyring/lib/server/router * @param {module:skyring/lib/server/node} node The node linked to the application hashring to pass with each request * @param {module:skyring/lib/timer} timer A timer instance associated with the application hashring to pass with each request * @example var x = new Router(node, timers) router.handle(req, res) */ function Router( node, timers ) { this.routes = new Map() this.route_options = new Map() this.node = node this.timers = timers } /** * Adds a new get handler to the router a new get handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.get = function get( path, fn ) { return this.route( path, 'GET', fn ) } /** * Adds a new put handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.put = function put( path, fn ) { return this.route( path, 'PUT', fn) } /** * Adds a new post handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.post = function post( path, fn ) { return this.route( path, 'POST', fn) } /** * Adds a new patch handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.patch = function patch( path, fn ) { return this.route( path, 'PATCH', fn) } /** * Adds a new delete handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.delete = function( path, fn ) { return this.route( path, 'DELETE', fn ) } /** * Adds a new opts handler to the router * @param {String} path The url path to route on * @param {Function} handler The handler function to call when the route is matched **/ Router.prototype.options = function options( path, fn ) { return this.route( path, 'OPTIONS', fn ) } /** * Adds a new route handler to the router * @param {String} path The url path to route on * @param {String} m handlerethod The http method to associate to the route * @param {Function} The handler function to call when the route is matched * @returns {module:skyring/lib/server/route} **/ Router.prototype.route = function route(path, method, fn) { const _method = method.toUpperCase() const map = this.routes.get(_method) || new Map() if (map.has(path)) { const rte = map.get(path) rte.use(fn) return rte } const rte = new Route(path, _method) rte.use(fn) map.set(path, rte) this.routes.set(_method, map) return rte } /** * Entrypoint for an incoming request * Customer properties are attached to an `$` object on the request rather than the request * itself to avoid V8 deopts / perf penalties * @param {http.IncomingMessage} req * @param {http.ServerResponse} res * @example http.createServer((req, res) =&gt; { router.handle(req, res) }) **/ Router.prototype.handle = function handle(req, res) { req.$ = new Request(req) res.$ = new Response(res) req.$.timers = this.timers const path = req.$.path const method = req.method.toUpperCase() const map = this.routes.get(method) if (map) { let rte = map.get(path) if (rte) { req.$.params = Object.create(null) return this.handleRoute(rte, req, res) } for (const route of map.values()) { const params = route.match(path) if (params) { req.$.params = params return this.handleRoute(route, req, res) } } } return notFound(req, res) } /** * Responsible for executing the middleware stack on the route ( including the end handler ) * @param {module:skyring/lib/server/route} route * @param {http.IncomingMessage} req * @param {http.ServerResponse} res **/ Router.prototype.handleRoute = function handleRoute(route, req, res) { debug('routing ', route.method, route.path) route.process(req, res, this.node, (err) =&gt; { if (err) return res.$.error(err) if (res.$.body) return res.$.json(res.$.body) return res.$.end() }) } function notFound( req, res ) { res.writeHead(404,{ 'Content-Type': 'application/json' }) res.end(JSON.stringify({message: 'Not Found' })) } module.exports = Router × Search results Close "},"lib_timer.js.html":{"id":"lib_timer.js.html","title":"Source: lib/timer.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/timer.js 'use strict' /** * Manage Timers on a node * @module skyring/lib/timer * @author Eric Satterwhite * @since 3.0.0 * @requires os * @requires crypto * @requires path * @requires levelup * @requires encoding-down * @requires debug * @requires skyring/lib/transports * @requires skyring/lib/nats * @requires skyring/lib/json */ const os = require('os') const crypto = require('crypto') const path = require('path') const levelup = require('levelup') const encode = require('encoding-down') const Transports = require('./transports') const nats = require('./nats') const json = require('./json') const conf = require('../conf') const debug = require('debug')('skyring:timer') const rebalance = require('debug')('skyring:rebalance') const store = require('debug')('skyring:store') const storage = Symbol('storage') const shutdown = Symbol.for('kShutdown') const kNode = Symbol('nodeid') const kRemove = Symbol('remove') const noop = () =&gt; {} const REBALANCE_SUB = 'skyring.rebalance' const EVENT_STATUS = { CREATED: 'create' , UPDATED: 'replace' , EXEC: 'execute' , CANCELLED: 'cancel' , FAIL: 'fail' , SUCCESS: 'success' , SHUTDOWN: 'shutdown' , READY: 'ready' , RECOVERY: 'recover' , REBALANCE: 'rebalance' , PURGE: 'purge' , EVICT: 'evict' } function generateId(id) { if (!id) return crypto.randomBytes(10).toString('hex') return crypto.createHash('sha1').update(id).digest('hex') } /** * Node style callback * @typedef {Function} Nodeback * @property {?Error} [err] An error instance. If not null, the results should not be trusted * @property {Object} result The results of the function execution **/ /** * @constructor * @alias module:skyring/lib/timer * @param {Object} [options] * @param {Object} [options.nats] Nats connection information * @param {String[]} [options.nats.servers] A list of nats `host:port` to connect to * @param {Object} [options.storage] Storage config options for level db * @param {String[]} [options.storage.backend=memdown] a requireable module name, or absolute path to a leveldb compatible backend. `memdown` and `leveldown` are built in * `leveldown` and `memdown` are installed by default * @param {String} options.storage.path A directory path to a leveldb instance. One will be created if it doesn't already exist. * If the backend is memdown, this is optional and randomly generated per timer instance * @param {Function} [onReady=()=&gt;{}] A callback function to call after initial recovery has completed * @param {String[]|Function[]} [options.transports] an array of custom transport functions, or requireable paths that resolve to functions. All transport function must be named functions * If not specified, configuration values will be used **/ class Timer extends Map { constructor(options = {}, cb = noop) { super() this.options = Object.assign({}, { nats: null , storage: null , transports: [] }, options) this._sid = null this._bail = false const store_opts = conf.get('storage') const opts = Object.assign(store_opts, this.options.storage) store(opts) if (!opts.path) { if (opts.backend === 'memdown') { this[kNode] = generateId() opts.path = path.join( os.tmpdir() , `skyring-${this[kNode]}` ) } else { const err = new Error('storage.path must be set with non memdown backends') err.code = 'ENOSTORAGE' throw err } } const backend = opts.backend === 'memdown' ? new (require(opts.backend)) : encode(require(opts.backend)(opts.path), {valueEncoding: 'json'}) debug('storage path', opts) this[kNode] = generateId(store_opts.path) this.nats = nats.createClient(this.options.nats) this.transports = new Transports(this.options.transports) this[storage] = levelup(backend, opts, (err) =&gt; { store('storage backend ready', store_opts) debug('node id', this[kNode]) this.recover(() =&gt; { this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.READY }, cb) }) }) } get id() { return this[kNode] } /** * Sets a new time instance. If The timer has lapsed, it will be executed immediately * @method module:skyring/lib/timer#create * @param {String} id A unique Id of the time * @param {Object} body Configuration options for the timer instance * @param {Number} body.timeout the time in milliseconds from now the timer should execute. This must be in the range: 0 &lt; timeout &lt; 2^31 - 1. * @param {String} body.data The data to be assicated with the timer, when it is executed * @param {Number} [body.created=Date.now()] timestamp when the timer is created. if not set, will default to now * @param {Object} callback Options for the outbound transport for the timer when it executes * @param {String} callback.transport The transport type ( http, etc ) * @param {String} transport.method The method the transport should use when executing the timer * @param {String} transport.uri The target uri for the transport when the timer executes * @param {Nodeback} callback * @example const crypto = require('crypto') id = crypto.createHash('sha1') .update(crypto.randomBytes(10)) .digest('hex') const options = { timeout: 4000 , data: \"this is a payload\" , callback: { transport: 'http' , method: 'put' , uri: 'http://api.domain.com/callback' } } timers.create(id, options, (err) =&gt; { if (err) throw err }) **/ create(id, body, cb) { const payload = body const transport = this.transports.get(payload.callback.transport) if (!transport) { const err = new Error(`Unknown transport ${payload.callback.transport}`) err.code = 'ENOTRANSPORT' setImmediate(cb, err) return null } if (this.has( id )) { const err = new Error(`Timer with id ${id} already exists`) err.code = 'EKEYEXISTS' setImmediate(cb, err) return null } const now = Date.now() const created = payload.created || now const elapsed = now - created if(now &gt; created + payload.timeout) { debug('executing stale timer') setImmediate( transport.exec.bind(transport) , payload.callback.method , payload.callback.uri , payload.data , id , this ) this.nats.publish('skyring:events', { type: EVENT_STATUS.EXEC , timer: id , node: this[kNode] , executed: Date.now() , created: created , payload: payload }, noop) cb(null, id) return null } const data = { created: created , id: id , payload: payload , timer: null } this[storage].put(id, data, (err) =&gt; { /* istanbul ignore if */ if (err) { console.error(err) cb(err, null) return null } debug('setting timer', id) this.nats.publish('skyring:events', { type: EVENT_STATUS.CREATED , timer: id , node: this[kNode] , created: data.created , payload: payload }, noop) data.timer = setTimeout( transport.exec.bind(transport) , payload.timeout - elapsed , payload.callback.method , payload.callback.uri , payload.data , id , this ).unref() this.set(id, data) cb(null, id) return null }) } /** * Clears the respective timer from storage and publishes a success event via nats * @method module:skyring/lib/timer#success * @param {String} id the is of the time to acknowledge as delivered successfully * @param {Nodeback} [callback] Callback to execute when the acknowledge is complete * @example timers.success('2e2f6dad-9678-4caf-bc41-8e62ca07d551') **/ success(id, cb = noop) { this[kRemove](id, (err) =&gt; { this.nats.publish('skyring:events', { type: EVENT_STATUS.SUCCESS , timer: id , node: this[kNode] }, cb) }) } /** * Clears the respective timer from storage and publishes a failure event via nats * @method module:skyring/lib/timer#failure * @param {String} id the is of the time to acknowledge as delivered successfully * @param {Error} error The error object to send with event objects * @param {Nodeback} [callback] Callback to execute when the acknowledge is complete * @example const error = Error('Remote server unavailable') error.code = 'ENOREMOTE' timers.failure('2e2f6dad-9678-4caf-bc41-8e62ca07d551', error) **/ failure(id, error, cb = noop) { this[kRemove](id, (err) =&gt; { this.nats.publish('skyring:events', { type: EVENT_STATUS.FAIL , timer: id , node: this[kNode] , message: error.message , stack: error.stack , error: error.code || error.name }, cb) }) } /** * Clears the respective timer from storage and publishes a cancelled event via nats * @method module:skyring/lib/timer#cancelled * @param {String} id the is of the time to acknowledge as delivered successfully * @param {Nodeback} [callback] Callback to execute when the acknowledge is complete * @example timers.cancel('2e2f6dad-9678-4caf-bc41-8e62ca07d551') **/ cancel(id, cb = noop) { this[kRemove](id, (err) =&gt; { if (err) return cb(err) this.nats.publish('skyring:events', { type: EVENT_STATUS.CANCELLED , timer: id , node: this[kNode] }, cb) }) } [kRemove](id, cb = noop) { this[storage].del(id, (err) =&gt; { if (err) return console.error('unable to purge %s', id, err) store('%s purged from storage', id, this.options.storage) }) const rec = this.get(id) if(!rec) { const err = new Error('Not Found') err.code = 'ENOENT' setImmediate(cb, err) return null } clearTimeout(rec.timer) this.delete(id) setImmediate(cb) debug('timer cleared', id) return null } rebalance(opts, node, cb = noop) { const size = this.size const batch = this[storage].batch() if(!size) return rebalance('node %s begin rebalance; timers: %d', this[kNode], size) this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.REBALANCE }, noop) const records = this.values() const run = ( obj ) =&gt; { if (node.owns(obj.id)) return clearTimeout(obj.timer) this.delete(obj.id) batch.del(obj.id) const data = Object.assign({}, obj.payload, { id: obj.id , created: obj.created }) rebalance('node %s no longer the owner of %s', this[kNode], obj.id) this.nats.publish('skyring:events', { node: this[kNode] , type: EVENT_STATUS.EVICT , timer: obj.id }, noop) cb(data) } for(var record of records) { run(record) } batch.write(() =&gt; { store('node %s rebalance batch delete complete', this[kNode]) }) } recover(cb = noop) { this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.RECOVERY }, noop) const fn = (data) =&gt; { store('recover', data.key) const out = Object.assign({}, data.value.payload, { id: data.value.id , created: data.value.created }) this.create(data.key, out, debug) } const stream = this[storage].createReadStream() stream .on('data', fn) .once('close', function () { debug('recover stream close') stream.removeListener('data', fn) cb &amp;&amp; cb() }) } /** * Updates a timer inplace * @method module:skyring/lib/timer#update * @param {String} id A unique Id of the time * @param {Object} body Configuration options for the timer instance * @param {Number} body.timeout Duration in milisecods to delay execution of the timer * @param {String} body.data The data to be assicated with the timer, when it is executed * @param {Object} callback Options for the outbound transport for the timer when it executes * @param {String} callback.transport The transport type ( http, etc ) * @param {String} transport.method The method the transport should use when executing the timer * @param {String} transport.uri The target uri for the transport when the timer executes * @param {Nodeback} callback * @example timers.update('0dc5a555-d0f6-49a0-b336-5befb0437288', { timeout: 4000 , data: \"this is a payload\" , callback: { transport: 'http' , method: 'put' , uri: 'http://api.domain.com/callback' } }) **/ update(id, body, cb) { this[kRemove](id, (err) =&gt; { if (err) return cb(err) debug('updating timer', id) this.create(id, body, cb) }) } close(cb){ this[storage].close(cb) } disconnect(cb = noop) { this[storage].close(noop) this.transports[shutdown](() =&gt; { this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.SHUTDOWN }, noop) this.nats.drainSubscription(this._sid, (err) =&gt; { if (err) return cb(err) this.nats.quit(cb) }) }) } /** * Triggers timers to be purged from this node canceling all locally pending timers, * and distributing them in the ring. It is assumed this node is no longer a ring member * @method module:skyring/lib/timer#shutdown * @param {Nodeback} callback Node style callback to execute when the function is complete **/ shutdown(cb) { const size = this.size if (!size) { this[storage].close() return this.transports[shutdown](() =&gt; { this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.SHUTDOWN }, noop) this.nats.drainSubscription(this._sid, (err) =&gt; { if (err) return cb(err) this.nats.quit(cb) }) }) } let sent = 0 let acks = 0 const batch = this[storage].batch() this.nats.unsubscribe(this._sid) this._sid = null const run = (obj) =&gt; { clearTimeout(obj.timer) batch.del(obj.id) const data = Object.assign({}, obj.payload, { id: obj.id , created: obj.created , count: ++sent }) this.nats.request(REBALANCE_SUB, data, (reply) =&gt; { if (++acks === size) { return batch.write(() =&gt; { store('batch delete finished') this.disconnect(cb) }) } rebalance( '%s of %s processed', acks, data.count, data.id) }) } this.nats.publish('skyring:node', { node: this[kNode] , type: EVENT_STATUS.PURGE }, noop) for(let record of this.values()) { run(record) } this.clear() } /** * Starts an internal nats queue * @method module:skyring/lib/timer#watch * @param {String} key The name of the nats queue to create * @param {Nodeback} callback Node style callback to execute when the function has finished execution **/ watch(key, cb) { if (this._bail) return const opts = { queue: key } this._sid = this.nats.subscribe(REBALANCE_SUB, opts, (data, reply) =&gt; { if (reply) this.nats.publish(reply, {node: this[kNode], timer: data.id}) if(this._bail) return cb(null, data) }) return this._sid } } module.exports = Timer × Search results Close "},"lib_transports_index.js.html":{"id":"lib_transports_index.js.html","title":"Source: lib/transports/index.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/transports/index.js 'use strict'; /** * Loads and maintains all transports * @module skyring/lib/transports * @author Eric Satterwhite * @tutorial transports * @since 1.0.0 * @requires debug * @requires skyring/lib/transports/http * @requires skyring/conf */ const debug = require('debug')('skyring:transports') const Callback = require('./callback') const Http = require('./http') const toArray = require('../lang/array/to-array') const conf = require('../../conf') const kLoad = Symbol('kLoad') const kShutdown = Symbol.for('kShutdown') const ENV = conf.get('node_env') const defaults = toArray(conf.get('transport')) /** * * @typedef {function} TransportHandler * @param {String} method * @param {String} uri * @param {String} Payload * @param {String} id * @param {LevelUp} storage A levelup instance container all curring timer data **/ /** * @alias module:skyring/lib/transports * @constructor * @param {TransportHandler|TransportHandler[]|String|String[]} transports Custom transports to register * This can be a Transport class or a * @example const path = require('path') const Skyring = require('skyring') const kType = Symbol.for('SkyringTransport') class Fizzbuzz extends Skyring.Transport { constructor(opts) { super(opts) this.name = 'fizzbuzz' } exec (method, uri, payload, id, timer_store) { // send payload to uri... timer_store.success(id) } shutdown(cb) { // drain connections... // free up event loop cb() } static [Symbol.hasInstance](instance) { return instance[kType] === 'fizzbuzztransport' } get [Symbol.toStringTag]() { return 'FizzbuzzTransport' } get [kType]() { return 'fizzbuzztransport' } } const server = new Skyring({ transports: [ 'my-transport-module' , Fizzbuzz , path.resolve(__dirname, '../transports/fake-transport') ] }) * @example const {Transports, Transport} = require('skyring') class Fizzbuzz extends Transport { constructor(opts) { super(opts) this.name = 'fizzbuzz' } exec (method, uri, payload, id, timer_store) { // send payload to uri... timer_store.remove(id) } shutdown(cb) { // drain connections... // free up event loop cb() } } const t = new Transports([ 'my-transport-module' , Fizzbuz , path.resolve(__dirname, '../transports/fake-transport') ]) **/ module.exports = class Transports extends Map { constructor(transports) { super() /** * Primary http transport * @memberof module:skyring/lib/transports * @property {Object} http The default HTTP transport **/ this.set(Http.name.toLowerCase(), new Http()) if(ENV === 'test') { this.set('callback', new Callback()) } this[kLoad](toArray(transports)) } [kLoad](paths) { const transports = new Set(defaults.concat(toArray(paths))) for (const path of transports) { const transport = typeof path === 'string' ? require(path) : path if (typeof transport !== 'function') { throw new TypeError('A Transport must export a function') } if (typeof transport.prototype.exec !== 'function') { throw new TypeError('A Transport must have an \"exec\" function') } if (transport.prototype.exec.length !== 5) { throw new Error('Transports must accept five parameters') } if (typeof transport.name !== 'string' || transport.name.length &lt;= 0) { throw new TypeError('transports.name is required and must be a string') } const name = transport.name.toLowerCase() if (this.has(name)) { const error = new Error(`A transport with name ${name} is already defined`) error.name = 'EEXIST' throw error } debug('loading %s transport', name) const instance = new transport( conf.get(`transports:${name}`) ) this.set(name, instance) } } [kShutdown](cb) { const keys = Array.from(this.values()) const run = () =&gt; { if (!keys.length) return cb() const transport = keys.pop() if (typeof transport.shutdown === 'function') { debug(`shutdown ${transport.name} transport`) return transport.shutdown(run) } run() } run() } } × Search results Close "},"lib_transports_http.js.html":{"id":"lib_transports_http.js.html","title":"Source: lib/transports/http.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/transports/http.js 'use strict'; /** * The Http transport backend * @module skyring/lib/transports/http * @author Eric Satterwhite * @since 1.0.0 * @requires http * @requires request * @requires debug * @requires skyring/lib/timer */ const STATUS_CODES = require('http').STATUS_CODES const phin = require('phin').unpromisified const debug = require('debug')('skyring:transport:http') const Transport = require('./transport') const {name, version} = require('../../package.json') const method_exp = /^(post|put|patch|delete|get|options|head)$/i const kType = Symbol.for('SkyringTransport') const TRANSPORT = 'httptransport' const USER_AGENT = `${name}/${version}` /** * Dispatches an http request * @function * @alias module:skyring/lib/transports/http * @param {String} method The http method to use when dispatching the request * @param {String} url the url to target when dispatching * @param {String} payload The data payload to include in the request * @param {String} id The id of the timer being executed * @param {module:skyring/lib/timer} cache A timer cache instance to delete from after execution **/ class Http extends Transport { constructor(options) { super(options) this.name = 'http' } static [Symbol.hasInstance](instance) { return instance[kType] === TRANSPORT } exec(method, url, payload, id, cache) { const body = payload || '' if (!method_exp.test(method)) { const pending = cache.get(id) pending &amp;&amp; clearTimeout(pending.timer) const err = new Error(`Invalid http verb ${method}`) err.code = 'ESRHTTP' cache.failure(id, err) debug('unable to execute http transport', method, id) return } debug('executing http transport %s', id, method) phin({ url: url , data: body , method: method , headers: { 'User-Agent': USER_AGENT } }, (err, res) =&gt; { if (err) { debug('timer err', err) return cache.failure(id, err) } if (res.statusCode &gt; 299) { debug('timer fail', res.statusCode, body) const error = new Error(STATUS_CODES[res.statusCode]) error.code = res.statusCode = res.statusCode console.error(error, body) return cache.failure(id, error) } debug('timer sucess') return cache.success(id) }) } get [kType]() { return TRANSPORT } get [Symbol.toStringTag]() { return 'SkyringHttpTransport' } } module.exports = Http × Search results Close "},"lib_transports_callback.js.html":{"id":"lib_transports_callback.js.html","title":"Source: lib/transports/callback.js","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Source: lib/transports/callback.js 'use strict' /** * A noop function transport for testing * @module skyring/lib/transports/timer * @author Eric Satterwhite * @since 1.0.4 * @requires skyring/lib/transports/transport */ const Transport = require('./transport') class Callback extends Transport { constructor(options) { super(options) } exec( method, url, payload, id, cache ) { setImmediate(() =&gt; { payload[method](url, id) return cache.success(id) }) } } module.exports = Callback × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Global Methods module:skyring/lib/json(json) Wrpper around try/catch of JSON parsing Parameters: Name Type Description json String A JSON string to parse Source: lib/json.js Returns: Type module:skyring/lib/json~Result Type Definitions Middleware(req, res, node, next) A route middleware function Parameters: Name Type Description req http.IncomingMessage The incomming request res http.ServerResponse The response object to be sent node module:skyring/lib/server/node The internal Ring Node instance next function The continuation callback to call when the middleware is finished Source: lib/server/route.js × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Modules Classes module:skyring/lib/server module:skyring/lib/server/node module:skyring/lib/server/response module:skyring/lib/server/route module:skyring/lib/server/router module:skyring/lib/timer module:skyring/lib/transports module:skyring/lib/transports/http skyring/lib/server/request × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Classes Classes module:skyring/lib/server module:skyring/lib/server/node module:skyring/lib/server/response module:skyring/lib/server/route module:skyring/lib/server/router module:skyring/lib/timer module:skyring/lib/transports module:skyring/lib/transports/http skyring/lib/server/request × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Tutorials Classes module:skyring/lib/server module:skyring/lib/server/node module:skyring/lib/server/response module:skyring/lib/server/route module:skyring/lib/server/router module:skyring/lib/timer module:skyring/lib/transports module:skyring/lib/transports/http skyring/lib/server/request × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module Docs API Docs Skyring A distributed reliable timer service providing setTimeout functionality in a distributed fashion. Skyring servers are clustered into a hashring using consistent hashing to partition timers to specific nodes in the ring. Skyring exposes a simple HTTP API that allows to you create and cancel timers. Timer execution comes in to the form of an HTTP webhook ( more transports to come ) Architecture Overview Install npm install -s skyring Run A Local Cluster Start a nats instance Download the nats binary and start it using the defaults $ gnats -D -V To verify that it is working, you can telnet directly to the server and ping it. $ telnet localhost 4222 &gt; ping PONG Skyring CLI If you intend to run skyring as is, it may be preferable to use the included binary over cloning the project. npm install -g skyring DEBUG=skyring:* skyring run -p 3000 -s localhost:3456 -s localhost:3455 Using in your project If you want to use the skyring directly, you can just require it and start it directly. most of the available environment and cli arguments can be passed to the skyring constructor. If you don't pass anything to the construct the default values are loaded from the appropriate sources // index.js const Skyring = require('skyring') const server = new Skyring() function onSignal() { server.close(()=&gt;{ console.log('shutting down'); }); } server.listen(3000, (err) =&gt; { if (err) throw err console.log('skyring listening at %s', 'http://0.0.0.0:3000') }) process.once('SIGINT', onSignal); process.once('SIGTERM', onSignal); This can then be started as a single node cluster $ DEBUG=* node . --channel:port=3455 --seeds='localhost:3455' The default settings expect a minimum of 2 servers on port 3455 and 3456 respectively. Start each server in a different terminal session # Seed node 1 $ DEBUG=skyring:* node index.js --channel:port=3455 -p 3000 # Seed node 2 $ DEBUG=skyring:* node index.js --channel:port=3456 -p 3001 If all goes well you should see a message like this skyring:ring ring bootstraped [ '127.0.0.1:3455', '127.0.0.1:3456' ] +1ms Thats it, you have 2 instances running w/ HTTP servers running on ports 3000 and 3001 Run via Docker Compose The Easiest way to run a small cluster is to use the included compose files. It is also a good way to see how to quickly configure a cluster Install Docker Compose $ npm start That is it! You have a 5 node Skyring cluster with a 3 node nats cluster behind an nginx proxy listening on port 8080 Timer API A request can be issued to any active node in the cluster. If that node is not responsible for the timer in question, it will forward the request directly to the node that is keeping network latency to a minimum. This makes Skyring very suitable for high performance, stateless, and distributed environments. The minimum recommended cluster size is 3 nodes, 2 of which being seed or bootstrapping nodes. A cluster of this size can average between 2K - 5K requests per second. Create a timer POST /timer Request Since timers managed in Skyring are done so through the use of setTimeout, there is a maximum timeout value of 2^31 - 1 or 2147483647 milliseconds, which is approximately 24.8 days. Attempting to request a timeout great than this value will result in a 400 Bad Request response. Additionally, the timeout must be greater than 0. curl -i -XPOST http://localhost:8080/timer -d '{ \"timeout\": 6000, \"data\" : \"{\\\"foo\\\":\\\"bar\\\"}\", \"callback\": { \"transport\": \"http\", \"method\": \"post\", \"uri\": \"http://api.someservice.com/hook/timeout\" } }' Response Headers For performance considerations, a body is not included in responses. Rather, HTTP headers are used to relay information about timer status. In the case of a Create request, the uri to the timer instance is returned in the Location header. HTTP/1.1 201 CREATED location: /timer/4adb026b-6ef3-44a8-af16-4d6be0343ecf Date: Fri, 23 Dec 2016 00:19:13 GMT Connection: keep-alive Content-Length: 0 Cancel A Timer DELETE /timer/:id Request curl -i -XDELETE http://localhost:8080/timer/4adb026b-6ef3-44a8-af16-4d6be0343ecf Response Headers HTTP/1.1 202 Accepted Date: Fri, 23 Dec 2016 00:22:12 GMT Connection: keep-alive Content-Length: 0 Crash Recovery Each Skyring node uses an internal levelup instance to record timers that it owns. When a node starts, it will check the configured database for any existing timers, and will immediately load them back into memory. By default, the memdown backend is used, and wil not persists between starts. To enable full persistence and recovery, you must configure skyring to use a persistent backend for levelup. Leveldown is installed by default. skyring run --storage:backend=leveldown --storage:path='/var/data/skyring' Custom Storage In situations when the local disk is not reliable enough, you can install and use any levelup backend to suite your needs. If, for example you want to off load data storage to a mongo or scylladb cluster, you would just include the backend package as a dependency in your project and specify it by name as the storage package. Options for the backend can be passed via the storage attribute npm install @skyring/scylladown skyring run --storage:backend=@skyring/scylladown --storage:path=skyring-1 --storage:contactPoints=0.0.0.0:9042 --storage:contactPoints=0.0.0.0:9043 skyring run --storage:backend=@skyring/scylladown --storage:path=skyring-2 --storage:contactPoints=0.0.0.0:9042 --storage:contactPoints=0.0.0.0:9043 Custom Transports Skyring ships with a single HTTP transport, but support custom transports. A transport is a JS class that defines the behavior to invoke when timer triggers. To register a transport, you can pass an array of transport classes, or module file paths to the skyring server constructor via via the transports option Optionally, for transports that need to perform some clean up work, a function property shutdown may be defined on the transport const path = require('path') const Skyring = require('skyring') class FizzBuzz extends Skyring.Transport { constructor(opts) { super(opts) } exec(method, uri, payload, id, timer_store) { // send payload to uri... console.log('fizzbuzz', method, id) timer_store.remove(id) } shutdown(cb) { // drain connections... // free up event loop cb() } } const server = new Skyring({ transports: [ 'my-transport-module' , FizzBuzz , path.resolve(__dirname, '../transports/fake-transport') ] }) The same can be achieved through CLI arguments or ENV vars via the transport key transport=foobar,fizzbuz node index.js node index --transport=foobar --transport=fizzbuz --transport=$PWD/../path/to/my-transport × Search results Close "},"module-keef.html":{"id":"module-keef.html","title":"Module: keef","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: keef The conf package reads configurations options in an overriding fashion from a number of sources. In order of importance: System level overrides Command line arguments Environment variables A configuration file(s) System specified defaults Overrides Overrides can not be overriden or changed at any point in time. The are defined in conf/lib/overrides.js and should be reserved for static run time properties. Conf serves as a central place to get that information. For example, the full path to the packages directory is resolved at run time and loaded in to the conf loader. It won't / can't change during run time, but may change in the future. By getting the information from conf, application logic does not need to change between restarts or releases. If overrides need to be change or added the overrides.js file must be changed Command Line Arguments Command line arguments are the highest level of maliable values. The can be used to set specific and nested values in the configuration JSON document but using a : spearator between keys. For example, using the flag: --foo:bar=1, would create an object like { \"foo\":{ \"bar\": 1 } } Environment Variables Environment variables work much the same as command line arguments. However, most bash implenetations don't read :'s very well, so the double underscore ( __ ) is used in its place foo__bar=1 npm start { \"foo\":{ \"bar\": 1 } } Conf Options The conf option can be set to read specific configuration from a file(s). The value should be a full path. If the path points to a directory, the conf loader will read all json files, sort them and load their values in an overriding order. Sorting is done in a descending, lexigraphical order. └── conf ├── 20-keef.json ├── 10-keef.json └── 30-keef.json Given the above directory of conf files, the server can be configured by pointing the conf arguments at the directory node server --conf=$HOME/conf The configruation would be read in the following priority 10-keef.json &lt; 20-keef.json &lt; 30-keef.json where 20 overrides 10, and 30 overrides 20. Static File Defaults To Simplify configuration for deployments, keef will look for configuration files in fixed locations eliminating the need for run time configuration. File Locations are as follows: a file in the rooot of your project with the name &lt;package.name&gt;.NODE_ENV.json For example, if the name attribute in your package.json is foobar, and the environment var NODE_ENV is set as production, the file look up is foobar.production.json. If NODE_ENV is not set, it would be foobar.development.json A json file named after your project name in the root of your project - foobar.json A json file named after your project in a .config directory in the current users home directory - .config/foobar.json A json file named after your project in the /etc directory - `/etc/foobar.json ETCD2 Clusters For distributed deployments, An etcd2 cluster may be used for configuration purposes. To enable etcd2 configuration loading, 2 environment variables should be set: etcd__hosts - A comma separated list of host:port addresses - etcd1.domain.com:4001,etcd2.domain.com:4001. etcd__namespace - a keyspace to keep data separate from everything else. Any configuration that is stored as object, we be translated into etcd directories automatically keef.set('a:b:c', 1) // Object data { \"a\": { \"b\": { \"c\": 1 } } } // etc data /a/b/c 1 System defaults defaults are what they sound like. Sane defaults for values that are needed to get the application running. They are located in the Defaults module and are used only as fallback values. Option Shorthands Top level options can be aliased. Short hand aliases can be found and defined in the Shorthands module of keef Flag Shorthand Description PORT p Specifies the port the server will bind to logger l specify the type(s) of logging transports for the server to use the following invocations are treated the same node server --PORT=3001 --logger=stdout --logger=file PORT=3001 logger=stdout nodeserver -l file node server -p 3001 -l stdout -l file Since: 0.1.0 Author: Eric Satterwhite Source: node_modules/keef/index.js Requires module:nconf module:path module:os module:debug module:fs module:keef/lib/shorthands module:keef/lib/defaults module:keef/lib/overrides × Search results Close "},"module-skyring.html":{"id":"module-skyring.html","title":"Module: skyring","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring Distributed timers as a service Exports a default server instance. If executed directly, the server will be started automoaticall and configured to auto rebalance on SIGINT and SIGTERM Since: 1.0.0 Author: Eric Satterwhite Source: index.js Requires module:http module:debug module:keef module:skyring/lib/server × Search results Close "},"module-skyring_conf.html":{"id":"module-skyring_conf.html","title":"Module: skyring/conf","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/conf Configuration options for skyring. See module:keef on ways to pass configuration Properties: Name Type Argument Default Description seeds String | Array.&lt;String&gt; &lt;optional&gt; 127.0.0.1:3455,127.0.0.1:3456 A list of seed nodes to use for bootstrapping a ring cluster channel Object Properties Name Type Argument Default Description host String &lt;optional&gt; 127.0.0.1 hostname or ip addres for tchannel to listen on port Number &lt;optional&gt; 3455 Port number for tchannel to bind to PORT Number &lt;optional&gt; 3000 The port number for the http API server to bind to nats Object Nats queue specific configuration Properties Name Type Argument Default Description hosts String | Array.&lt;String&gt; &lt;optional&gt; 127.0.0.1:4222 host:port of instances of a nats cluster. One is usually enough. options.storage Object &lt;optional&gt; Storage config options for level db Properties Name Type Argument Default Description backend Array.&lt;String&gt; &lt;optional&gt; memdown a requireable module name, or absolute path to a leveldb compatible backend leveldown and memdown are installed by default path String A directory path to a leveldb instance. One will be created if it doesn't already exist. Since: 1.0.0 Author: Eric Satterwhite Source: index.js × Search results Close "},"module-skyring_lib_json.html":{"id":"module-skyring_lib_json.html","title":"Module: skyring/lib/json","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/json JSON helpers (require(\"skyring/lib/json\"))(json) Wrpper around try/catch of JSON parsing Parameters: Name Type Description json String A JSON string to parse Source: lib/json.js Returns: Type module:skyring/lib/json~Result Type Definitions Result Composite JSON ojbect Type: Object Properties: Name Type Argument Default Description error Error &lt;optional&gt; &lt;nullable&gt; null An error if json parsing faile value Object the result of Json parsing Source: lib/json.js × Search results Close "},"module-skyring_lib_nats.html":{"id":"module-skyring_lib_nats.html","title":"Module: skyring/lib/nats","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/nats Small wrapper around nats for quickly connecting / disconnecting Since: 1.0.0 Author: Eric Satterwhite Source: lib/nats/index.js Example const nats= require('skyring/lib/nats') const client = nats.createClient() client.publish('foobar', JSON.stringify({'foo':'bar'}), () =&gt; { nats.quit() }) Requires module:url module:nats module:keef module:debug Methods createClient( [options]) Creates a new nats client Parameters: Name Type Argument Description options Object &lt;optional&gt; nats client configuration Properties Name Type Argument Default Description hosts String &lt;optional&gt; localhost:4222 a comma separated list of addresses of nats hosts to connect to Source: lib/nats/index.js Returns: A nats client instance Type NatsClient Example nats.createClient({ hosts:'nats-1.domain.com:4222,nats-2.domain.com:4223,localhost:4222' }) × Search results Close "},"module-skyring_lib_nats_parse-hosts.html":{"id":"module-skyring_lib_nats_parse-hosts.html","title":"Module: skyring/lib/nats/parse-hosts","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/nats/parse-hosts Function to parse and normalize nats host addresses Since: 10.0.0 Author: Eric Satterwhite Source: lib/nats/parse-hosts.js × Search results Close "},"module-skyring_lib_server.html":{"id":"module-skyring_lib_server.html","title":"Module: skyring/lib/server","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server Primary server instance for a skyring app. new (require(\"skyring/lib/server\"))( [options]) Extends: http.Server Parameters: Name Type Argument Default Description options Object &lt;optional&gt; Properties Name Type Argument Description node module:skyring/lib/server/node &lt;optional&gt; A customer node instance optiopns.node.host String &lt;optional&gt; host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0 ) options.node.port Number &lt;optional&gt; Port number for the node to listen on in the ring options.node.app String &lt;optional&gt; timers name of the active ring to join options.nats Object &lt;optional&gt; Properties Name Type Argument Description servers Array.&lt;String&gt; &lt;optional&gt; An array of nats host:port addresses to connect to options.transports Array.&lt;String&gt; | Array.&lt;function()&gt; &lt;optional&gt; an array of custom transport functions, or requireable paths that resolve to functions. All transport function must be named functions Since: 1.0.0 Author: Eric Satterwhite Source: lib/server/index.js Examples // Use only configuration values var server = new Server().listen(5000) var server = new Server({ node :{ host: 172.17.0.9 , port: 8456 , app: 'payback' } , nats: { servers: ['nats1.domain.com:4222', 'nats2.domain.com:4222'] } }) server.listen(5000) // Use a custom node instance var node = new Node({ host: 172.17.0.9 , port: 8456 , app: 'payback' }) var server = new Server({ node }) server.listen(5000) Requires module:http module:debug module:@esaterwhite/micromock module:skyring/lib/server/node module:skyring/lib/server/router module:skyring/lib/timer Methods close(callback) Removes a server from the ring, closes the http server and redistributes any pending timers Parameters: Name Type Description callback function A callback to be called when the server is completely shut down Source: lib/server/index.js listen(port [, host] [, backlog] [, callback]) Joins the node to the configured ring and starts the http server Parameters: Name Type Argument Default Description port Number Port number to listen on host String &lt;optional&gt; localhost host or ip address to listen on backlog Number &lt;optional&gt; callback function &lt;optional&gt; Callback function to call when the server is running Source: lib/server/index.js Returns: Type module:skyring/lib/server × Search results Close "},"module-skyring_lib_server_node.html":{"id":"module-skyring_lib_server_node.html","title":"Module: skyring/lib/server/node","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server/node Represents a participant in the Hashring new (require(\"skyring/lib/server/node\"))( [host] [, port] [, name] [, app]) Parameters: Name Type Argument Default Description host String &lt;optional&gt; host name for the node to listen on - 127.0.0.1 must be used for localhost ( not 0.0.0.0) port Number &lt;optional&gt; Port number for the node to listen on in the ring name String &lt;optional&gt; 'ringpop' name of the active ring to join app String &lt;optional&gt; timers app name of the active ring Source: lib/server/node.js Requires module:path module:events module:dns module:@skyringringpop module:tchannel module:debug module:keef Members &lt;static, readonly&gt; name Properties: Name Type Description name String The name of the node Source: lib/server/node.js Methods close(callback) Removes itself from the ring and closes and connections Parameters: Name Type Description callback function A callback function to call when the ring is closed Source: lib/server/node.js handle(handler) Adds a request handler to the active ringpop instance Parameters: Name Type Description handler function A request handler for incoming requests from the ring Source: lib/server/node.js handleOrProxy(key, req, res) Determines if this instance is responsible for a specific key. proxies the request if it is not Parameters: Name Type Description key String The key to use to do a node lookup in the ring req http.IncomingMessage | module:skyring/lib/server/mock.Request an http request object res http.ServerResponse | module:skyring/lib/server/mock.Response an http response object Source: lib/server/node.js Returns: Type Boolean Example const handle = node.handleOrProxy('foobar', req, res) if (!handle) return; // deal with request join( [seeds], callback) Does the work of configuring tchannel and joining itself into a ringpop ring Parameters: Name Type Argument Description seeds Array.&lt;String&gt; &lt;optional&gt; An array of node addresses to use as boot strapping nodes callback function Function to call when the node has completed the bootstrap process Source: lib/server/node.js Example node.join(['node-1:5555', '172.10.0.4:4563'], (err) =&gt; { if (err) throw err }) leave(callback) Deprecated: use close method Parameters: Name Type Description callback function Callback function to call when the eviction process is complete Deprecated: 10.0.0 Source: lib/server/node.js lookup(key) Lookup the address of the server responsible for a given key Parameters: Name Type Description key String The key to look up Source: lib/server/node.js Returns: A server address Type String owns(key) Determines if this node is responsible for a specific key Parameters: Name Type Description key String The key to use Source: lib/server/node.js Returns: Type Boolean × Search results Close "},"module-skyring_lib_server_request.html":{"id":"module-skyring_lib_server_request.html","title":"Module: skyring/lib/server/request","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server/request Simple wrapper around the http request object to avoid deopts Since: 1.0.0 Author: Eric Satterwhite Source: lib/server/request.js Requires module:url module:querystring × Search results Close "},"module-skyring_lib_server_response.html":{"id":"module-skyring_lib_server_response.html","title":"Module: skyring/lib/server/response","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server/response Simple wrapper around the http response object to avoid deopts new (require(\"skyring/lib/server/response\"))(res) Parameters: Name Type Description res ServerResponse A ServerResponse from the node http module Source: lib/server/response.js Requires module:debug Methods end( [chunk]) Ends the response Parameters: Name Type Argument Description chunk String &lt;optional&gt; An optional chunk to write be for closing the stream Source: lib/server/response.js Returns: Type module:skyring/lib/server/response error(err [, msg]) Responsible for returning a response in the case of an error If the error has a message, it will be sent with the x-skyring-reason http header if the error has a statusCode property, that will be used, otherwise a 500 will be returned Parameters: Name Type Argument Description err Error | number The error to handle msg String &lt;optional&gt; In the case err is a number, this will be used as the message Source: lib/server/response.js get(header) Returns the value of a response header Parameters: Name Type Description header String The name of the header to get Source: lib/server/response.js Returns: The header value, if it is set Type String json(body) Helper for responding with an Object. Will serialize the object, and set the Content-Type header to application/json Parameters: Name Type Description body Object The object to set as the response body Source: lib/server/response.js Returns: Type module:skyring/lib/server/response send( [chunk]) Writes a chunk to the response stream Parameters: Name Type Argument Description chunk String &lt;optional&gt; The chunk to write Source: lib/server/response.js Returns: Type module:skyring/lib/server/response set(header, The) Sets a response header Parameters: Name Type Description header String The header to set The String header value to set Source: lib/server/response.js Returns: Type module:skyring/lib/server/response status(code) Sets the status code on the response object Parameters: Name Type Description code Number The http Status code to set Source: lib/server/response.js Returns: Type module:skyring/lib/server/response × Search results Close "},"module-skyring_lib_server_route.html":{"id":"module-skyring_lib_server_route.html","title":"Module: skyring/lib/server/route","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server/route represents the middleware stack for a url / method combination new (require(\"skyring/lib/server/route\"))(path, method) Parameters: Name Type Description path String the url pattern to match method String The http method to respect Source: lib/server/route.js Example var rte = new Route('/foo/:id', 'POST') rte.use((req, res, node, next) =&gt; { if(req.method === 'DELETE') { const err = new Error('Not Implemented') err.statusCode = 501 next(err) } }) Requires module:path-to-regexp Methods before(fn) Adds a middleware function to the beginning of the internal route stack Parameters: Name Type Description fn module:skyring/lib/server/route~Middleware a the middelware function to add Source: lib/server/route.js use(fn) Adds a middleware function to the end of the internal route stack Parameters: Name Type Description fn module:skyring/lib/server/route~Middleware a the middelware function to add Source: lib/server/route.js × Search results Close "},"module-skyring_lib_server_router.html":{"id":"module-skyring_lib_server_router.html","title":"Module: skyring/lib/server/router","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/server/router Simple router class for directing requests new (require(\"skyring/lib/server/router\"))(node, timer) Parameters: Name Type Description node module:skyring/lib/server/node The node linked to the application hashring to pass with each request timer module:skyring/lib/timer A timer instance associated with the application hashring to pass with each request Source: lib/server/router.js Example var x = new Router(node, timers) router.handle(req, res) Requires module:skyring/lib/server/route module:skyring/lib/server/request module:skyring/lib/server/response Methods delete(path, handler) Adds a new delete handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js get(path, handler) Adds a new get handler to the router a new get handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js handle(req, res) Entrypoint for an incoming request Customer properties are attached to an $ object on the request rather than the request itself to avoid V8 deopts / perf penalties Parameters: Name Type Description req http.IncomingMessage res http.ServerResponse Source: lib/server/router.js Example http.createServer((req, res) =&gt; { router.handle(req, res) }) handleRoute(route, req, res) Responsible for executing the middleware stack on the route ( including the end handler ) Parameters: Name Type Description route module:skyring/lib/server/route req http.IncomingMessage res http.ServerResponse Source: lib/server/router.js options(path, handler) Adds a new opts handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js patch(path, handler) Adds a new patch handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js post(path, handler) Adds a new post handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js put(path, handler) Adds a new put handler to the router Parameters: Name Type Description path String The url path to route on handler function The handler function to call when the route is matched Source: lib/server/router.js route(path, m, The) Adds a new route handler to the router Parameters: Name Type Description path String The url path to route on m String handlerethod The http method to associate to the route The function handler function to call when the route is matched Source: lib/server/router.js Returns: Type module:skyring/lib/server/route × Search results Close "},"module-skyring_lib_timer.html":{"id":"module-skyring_lib_timer.html","title":"Module: skyring/lib/timer","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/timer Manage Timers on a node new (require(\"skyring/lib/timer\"))( [options] [, onReady]) Parameters: Name Type Argument Default Description options Object &lt;optional&gt; Properties Name Type Argument Description nats Object &lt;optional&gt; Nats connection information Properties Name Type Argument Description servers Array.&lt;String&gt; &lt;optional&gt; A list of nats host:port to connect to storage Object &lt;optional&gt; Storage config options for level db Properties Name Type Argument Default Description backend Array.&lt;String&gt; &lt;optional&gt; memdown a requireable module name, or absolute path to a leveldb compatible backend. memdown and leveldown are built in leveldown and memdown are installed by default path String A directory path to a leveldb instance. One will be created if it doesn't already exist. If the backend is memdown, this is optional and randomly generated per timer instance onReady function &lt;optional&gt; ()=&gt;{} A callback function to call after initial recovery has completed options.transports Array.&lt;String&gt; | Array.&lt;function()&gt; &lt;optional&gt; an array of custom transport functions, or requireable paths that resolve to functions. All transport function must be named functions If not specified, configuration values will be used Source: lib/timer.js Requires module:os module:crypto module:path module:levelup module:encoding-down module:debug module:skyring/lib/transports module:skyring/lib/nats module:skyring/lib/json Methods cancelled(id [, callback]) Clears the respective timer from storage and publishes a cancelled event via nats Parameters: Name Type Argument Description id String the is of the time to acknowledge as delivered successfully callback Nodeback &lt;optional&gt; Callback to execute when the acknowledge is complete Source: lib/timer.js Example timers.cancel('2e2f6dad-9678-4caf-bc41-8e62ca07d551') create(id, body, callback, callback) Sets a new time instance. If The timer has lapsed, it will be executed immediately Parameters: Name Type Description id String A unique Id of the time body Object Configuration options for the timer instance Properties Name Type Argument Default Description timeout Number the time in milliseconds from now the timer should execute. This must be in the range: 0 &lt; timeout &lt; 2^31 - 1. data String The data to be assicated with the timer, when it is executed created Number &lt;optional&gt; Date.now() timestamp when the timer is created. if not set, will default to now callback Object Options for the outbound transport for the timer when it executes Properties Name Type Description transport String The transport type ( http, etc ) transport.method String The method the transport should use when executing the timer transport.uri String The target uri for the transport when the timer executes callback Nodeback Source: lib/timer.js Example const crypto = require('crypto') id = crypto.createHash('sha1') .update(crypto.randomBytes(10)) .digest('hex') const options = { timeout: 4000 , data: \"this is a payload\" , callback: { transport: 'http' , method: 'put' , uri: 'http://api.domain.com/callback' } } timers.create(id, options, (err) =&gt; { if (err) throw err }) failure(id, error [, callback]) Clears the respective timer from storage and publishes a failure event via nats Parameters: Name Type Argument Description id String the is of the time to acknowledge as delivered successfully error Error The error object to send with event objects callback Nodeback &lt;optional&gt; Callback to execute when the acknowledge is complete Source: lib/timer.js Example const error = Error('Remote server unavailable') error.code = 'ENOREMOTE' timers.failure('2e2f6dad-9678-4caf-bc41-8e62ca07d551', error) shutdown(callback) Triggers timers to be purged from this node canceling all locally pending timers, and distributing them in the ring. It is assumed this node is no longer a ring member Parameters: Name Type Description callback Nodeback Node style callback to execute when the function is complete Source: lib/timer.js success(id [, callback]) Clears the respective timer from storage and publishes a success event via nats Parameters: Name Type Argument Description id String the is of the time to acknowledge as delivered successfully callback Nodeback &lt;optional&gt; Callback to execute when the acknowledge is complete Source: lib/timer.js Example timers.success('2e2f6dad-9678-4caf-bc41-8e62ca07d551') update(id, body, callback, callback) Updates a timer inplace Parameters: Name Type Description id String A unique Id of the time body Object Configuration options for the timer instance Properties Name Type Description timeout Number Duration in milisecods to delay execution of the timer data String The data to be assicated with the timer, when it is executed callback Object Options for the outbound transport for the timer when it executes Properties Name Type Description transport String The transport type ( http, etc ) transport.method String The method the transport should use when executing the timer transport.uri String The target uri for the transport when the timer executes callback Nodeback Source: lib/timer.js Example timers.update('0dc5a555-d0f6-49a0-b336-5befb0437288', { timeout: 4000 , data: \"this is a payload\" , callback: { transport: 'http' , method: 'put' , uri: 'http://api.domain.com/callback' } }) watch(key, callback) Starts an internal nats queue Parameters: Name Type Description key String The name of the nats queue to create callback Nodeback Node style callback to execute when the function has finished execution Source: lib/timer.js Type Definitions Nodeback() Node style callback Properties: Name Type Argument Description err Error &lt;optional&gt; &lt;nullable&gt; An error instance. If not null, the results should not be trusted result Object The results of the function execution Source: lib/timer.js × Search results Close "},"module-skyring_lib_transports.html":{"id":"module-skyring_lib_transports.html","title":"Module: skyring/lib/transports","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/transports Loads and maintains all transports new (require(\"skyring/lib/transports\"))(transports) Parameters: Name Type Description transports TransportHandler | Array.&lt;TransportHandler&gt; | String | Array.&lt;String&gt; Custom transports to register This can be a Transport class or a Source: lib/transports/index.js Examples const path = require('path') const Skyring = require('skyring') const kType = Symbol.for('SkyringTransport') class Fizzbuzz extends Skyring.Transport { constructor(opts) { super(opts) this.name = 'fizzbuzz' } exec (method, uri, payload, id, timer_store) { // send payload to uri... timer_store.success(id) } shutdown(cb) { // drain connections... // free up event loop cb() } static [Symbol.hasInstance](instance) { return instance[kType] === 'fizzbuzztransport' } get [Symbol.toStringTag]() { return 'FizzbuzzTransport' } get [kType]() { return 'fizzbuzztransport' } } const server = new Skyring({ transports: [ 'my-transport-module' , Fizzbuzz , path.resolve(__dirname, '../transports/fake-transport') ] }) const {Transports, Transport} = require('skyring') class Fizzbuzz extends Transport { constructor(opts) { super(opts) this.name = 'fizzbuzz' } exec (method, uri, payload, id, timer_store) { // send payload to uri... timer_store.remove(id) } shutdown(cb) { // drain connections... // free up event loop cb() } } const t = new Transports([ 'my-transport-module' , Fizzbuz , path.resolve(__dirname, '../transports/fake-transport') ]) Requires module:debug module:skyring/lib/transports/http module:skyring/conf Type Definitions TransportHandler(method, uri, Payload, id, storage) Parameters: Name Type Description method String uri String Payload String id String storage LevelUp A levelup instance container all curring timer data Source: lib/transports/index.js × Search results Close "},"module-skyring_lib_transports_http.html":{"id":"module-skyring_lib_transports_http.html","title":"Module: skyring/lib/transports/http","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/transports/http Dispatches an http request The Http transport backend new (require(\"skyring/lib/transports/http\"))(method, url, payload, id, cache) Parameters: Name Type Description method String The http method to use when dispatching the request url String the url to target when dispatching payload String The data payload to include in the request id String The id of the timer being executed cache module:skyring/lib/timer A timer cache instance to delete from after execution Source: lib/transports/http.js Requires module:http module:request module:debug module:skyring/lib/timer × Search results Close "},"module-skyring_lib_transports_timer.html":{"id":"module-skyring_lib_transports_timer.html","title":"Module: skyring/lib/transports/timer","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Module: skyring/lib/transports/timer A noop function transport for testing Since: 1.0.4 Author: Eric Satterwhite Source: lib/transports/callback.js Requires module:skyring/lib/transports/transport × Search results Close "},"skyring_lib_server_request.html":{"id":"skyring_lib_server_request.html","title":"Class: skyring/lib/server/request","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Class: skyring/lib/server/request skyring/lib/server/request new skyring/lib/server/request(req) Parameters: Name Type Description req IncommingMessage An IncomingMessage from the node http module Source: lib/server/request.js Methods get(header) Returns the value of a header, if it exists Parameters: Name Type Description header String The name of the header to lookup Source: lib/server/request.js Returns: The request header, if set Type String × Search results Close "},"tutorial-bootstrap.html":{"id":"tutorial-bootstrap.html","title":"Tutorial: Bootstrapping A Cluster","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Bootstrapping A Cluster The start up process in each Skyring server includes a discovery phase referred to as the bootstrap phase. The bootstrap process is the process of each of the designated seed nodes coming online and discovering each other. Once all of the seed nodes successfully comes one line, the clusters is considered to be bootstrapped and the HTTP server will start up. Once the ring has been bootstrapped it will continue to function even if the seed node go down. However, new node will be able to join the ring until all of the seeds have come back online. NOTE It is highly recommended that seeds get a static IP address or you will have to continually re-configure you clusters. While not a requirement, each skyring instance should be on it's own host machine. Seed Nodes Seed nodes are used by other nodes in the cluster to determine the topology of the cluster. Besides that, they are the same as non-seed nodes. A Cluster must have one ore more seeds to function. When creating a new Skyring node, you specify cluster seeds with the seeds property, command line flag, or environment variable. Seeds must be in the format of &lt;IP ADDRESS&gt;:&lt;PORT&gt;. A hostname can be used in place of an IP address, but it must be resolvable by DNS. All nodes in the cluster, seeds or not, must have the same seed configuration. Command Line Flags $ skyring run --seeds=10.50.0.5:3456 --seeds=10.60.0.5:3456 Environment Variables $ seeds=10.50.0.5:3456,10.60.0.5:3456 skyring run Server Configuration const Skyring = require('skyring') const server = new Skyring({ seeds: ['10.50.0.5:3456', '10.60.0.5:3456'] }) Skyring Channel Configuration Each Skyring node uses an internal communication channel to talk to to the other seed nodes in the cluster during the bootstrap process. You must make sure that one of the listed seeds matches the channel configuration of one of the nodes. Single node cluster It is possible to bootstrap a single node cluster by specifying one seed node and configuring the internal node configuration match const Skyring = require('skyring') const server = new Skyring({ seeds: ['127.0.0.1:3456'] , node: { host: '127.0.0.1' , port: 3456 , app: 'dev' } }) server.listen(3000, null, null, () =&gt; { console.log('skyring bootstrapped') }) This will start a skyring node with a communication channel listing on port 3456 of localhost, and looking for a seed node on the same port. So, this node bootstraps itself, and starts the HTTP server Two node cluster Similarly to bootstrap a two ring cluster, each server instance must list all seed nodes. // Node 1 const Skyring = require('skyring') const server = new Skyring({ seeds: ['127.0.0.1:3455', '127.0.0.1:3456'] , node: { host: '127.0.0.1' , port: 3455 , app: 'dev' } }) server.listen(3000, null, null, () =&gt; { console.log('skyring bootstrapped') }) // Node 2 const Skyring = require('skyring') const server = new Skyring({ seeds: ['127.0.0.1:3455', '127.0.0.1:3456'] , node: { host: '127.0.0.1' , port: 3456 , app: 'dev' } }) server.listen(3001, null, null, () =&gt; { console.log('skyring bootstrapped') }) In this Example, we start two seeds on localhost ports 3455 and 3456. Each one is configured to find itself and the other node in the cluster. Once the initial cluster bootstrap is complete and the seeds are online, we can start adding additional nodes to the ring cluster. Add Non-Seed Nodes To add additional server instances, we just start more services pointed at the 2 seed nodes with node configuration and a unused port for the HTTP server // Node 3 const Skyring = require('skyring') const server = new Skyring({ seeds: ['127.0.0.1:3455', '127.0.0.1:3456'] , node: { host: '127.0.0.1' , port: 3457 , app: 'dev' } }) server.listen(3002, null, null, () =&gt; { console.log('server 3 ready') }) // Node 4 const Skyring = require('skyring') const server = new Skyring({ seeds: ['127.0.0.1:3455', '127.0.0.1:3456'] , node: { host: '127.0.0.1' , port: 3458 , app: 'dev' } }) server.listen(3003, null, null, () =&gt; { console.log('Server 4 ready') }) × Search results Close "},"tutorial-transports.html":{"id":"tutorial-transports.html","title":"Tutorial: Custom Transports","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Official TCP Transport Official ZMQ Transport Custom Transports The Transports systems is how skyring executes timeouts. When a timer lapses, a message is delivered to destination that you have defined. How that message is delivered is configurable. Out of the box, Skyring comes with an HTTP transport. Defining your own transport is pretty simple, and you can use any of the tools you are currently used to using. STDOUT Transport To illustrate the process, we're going to make a simple transport handler to write the data to stdout. Basically, speaking a transport is just a node.js module that exports a class. The class must, at the very least, have an exec function. 'use strict' const os = require('os') module.exports = class Stdout { constructor(opts) { // do set up } exec (method, url, payload, id, storage) { // deliver the message process.stdout.write(payload); process.stdout(os.EOL); // clear the timer storage.uccessid); } get [Symbol.toStringTag]() { return 'SkyringSTDOutTransport' } }; Pretty simple. We just write the data to the stdout out stream attached to the process, of course, be sure to remove the timer reference from the skyring internal storage. To load your transport into a skyring server, you can pass an array of transports when instantiating as server instance. The array can contain references to the transport itself, or as string that can be passed to require 'use strict' const Skyring = require('skyring') const Stdout = require('./transports/stdout') const server = new Skyring({ transports: [Stdout] , seeds: ['localhost:3455'] }) server.listen(3000) Done. Just be sure that every skyring node in the cluster has all of the same transports loaded so they have the capability to execute all of the timers. Other than that, we can start using our new transport by referencing it by name in the transport field of the request to create a new timer. curl -XPOST http://localhost:3000/timer -H 'Content-Type: application/json' -d '{ \"timeout\":3000 , \"data\":\"hello world!\" , \"callback\": { \"transport\": \"stdout\" , \"method\":\"unused\" , \"uri\": \"unused\" } }' It is pretty simple and straight forward to build your own transport layer for Skyring. It can be a simple function, or for more complex use cases, you can build out entire npm packages using whatever tools you want. This makes the transport system in skyring very flexible, powerful, and easy to use. × Search results Close "},"tutorial-skyring-tcp.html":{"id":"tutorial-skyring-tcp.html","title":"Tutorial: Official TCP Transport","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Official TCP Transport An officially supported TCP based transport with connection pooling for Skyring. This transport Will maintain a pool of connections to the destination of your choosing. It is responsible for growing and shrinking the pool as needed and re-creating connections if they happen to error or close unexpectedly. Installation $ npm install @skyring/tcp-transport --save Usage Skyring accepts an array property transports. Each entry can be a string or a named function. If given a string, skyring will pass it to require which must resolve to a named function const Skyring = require('skyring') const server = new Skyring({ transports: ['@skyring/tcp-transport'] , seeds: ['localhost:3455'] }) server.listen(3000) Example Echo Server // tcp echo server 'use strict' let count = 0 const port = process.env.PORT || 5555 const net = require('net') const server = net.createServer((socket) =&gt; { socket.on('data', (chunk) =&gt; { console.log(`${++count} ` + chunk) }) }) process.once('SIGINT', onSignal) process.once('SIGTERM', onSignal) server.listen(port, (err) =&gt; { if (err) { console.log(err) process.exitCode = 1 } console.log('server listening') }) function onSignal() { server.close() } $ curl -XPOST http://localhost:3000/timer -H 'Content-Type: application/json' -d '{ \"timeout\":3000 , \"data\":\"hello world!\" , \"callback\": { \"transport\": \"tcp\" , \"method\":\"unused\" , \"uri\": \"tcp://0.0.0.0:5555\" } }' &gt;&gt;&gt; 1 hello world ! × Search results Close "},"tutorial-skyring-zmq.html":{"id":"tutorial-skyring-zmq.html","title":"Tutorial: Official ZMQ Transport","body":" Skyring Modules keefskyringskyring/confskyring/lib/jsonskyring/lib/natsskyring/lib/nats/parse-hostsskyring/lib/serverskyring/lib/server/nodeskyring/lib/server/requestskyring/lib/server/responseskyring/lib/server/routeskyring/lib/server/routerskyring/lib/timerskyring/lib/transportsskyring/lib/transports/httpskyring/lib/transports/timer Classes skyring/lib/server/request Tutorials Bootstrapping A ClusterCustom Transports Global Global Official ZMQ Transport An Officially support ZMQ transport allowing for transports over PUSH or PUB socket types Installation $ npm install @skyring/zmq-transport --save Usage Skyring accepts an array property transports. Each entry can be a string or a named function. If given a string, skyring will pass it to require which must resolve to a named function. Use the method option of the timer definition to specify the socket type on the connection. NOTE That connections are long lived and once a type of socket has been created for a given host, it is not possible ( or recommeded ) to change them. I.E., attempting to transition from PUSH to PUB const Skyring = require('skyring') const server = new Skyring({ transports: ['@skyring/zmq-transport'] , seeds: ['localhost:3455'] }) server .listen(3000) Example PUSH handler 'use strict' let count = 0 const port = process.env.PORT || 5555 const zmq = require('zmq') const socket = zmq.socket('pull') socket.on('message', (evt, payload) =&gt; { console.log(payload.toString('utf8')) }) socket.connect(`tcp://0.0.0.0:${port}`) process.once('SIGINT', onSignal) process.once('SIGTERM', onSignal) function onSignal() { socket.disconnect() socket.close() } $ curl -XPOST http://localhost:3000/timer -H 'Content-Type: application/json' -d '{ \"timeout\":3000 , \"data\":\"hello world!\" , \"callback\": { \"transport\": \"zmq\" , \"method\":\"push\" , \"uri\": \"tcp://0.0.0.0:5555\" } }' &gt;&gt;&gt; 1 hello world ! Example PUB handler 'use strict' let count = 0 const port = process.env.PORT || 5555 const zmq = require('zmq') const socket = zmq.socket('sub') socket.on('message', (evt, payload) =&gt; { console.log(payload.toString('utf8')) }) socket.subscribe('timeout') socket.connect(`tcp://0.0.0.0:${port}`) process.once('SIGINT', onSignal) process.once('SIGTERM', onSignal) function onSignal() { socket.disconnect() socket.close() } $ curl -XPOST http://localhost:3000/timer -H 'Content-Type: application/json' -d '{ \"timeout\":3000 , \"data\":\"hello world!\" , \"callback\": { \"transport\": \"zmq\" , \"method\":\"pub\" , \"uri\": \"tcp://0.0.0.0:5555\" } }' # start as many pub handlers as you want &gt;&gt;&gt; 1 hello world ! &gt;&gt;&gt; 1 hello world ! &gt;&gt;&gt; 1 hello world ! × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
